import React, { useRef, useEffect, useState, useCallback } from 'react';
import { Canvas, useThree, useFrame } from '@react-three/fiber';
import { OrbitControls, Environment, MapControls } from '@react-three/drei';
import { Vector3 } from 'three';
import { gsap } from 'gsap';
import Model from './Model';
import BirdFlocks from './BirdFlock';
import Clouds from './Clouds';
import Drones from './Drone';

// Kamera kontrol√º i√ßin custom hook
function useMapControls() {
    const { camera } = useThree();
    const controlsRef = useRef<any>(null);
    const lastValidTargetRef = useRef(new Vector3());
    const lastValidPositionRef = useRef(new Vector3());
    const lastRotationRef = useRef(-Math.PI / 2); // Son rotasyon deƒüerini sakla
    const [center, setCenter] = useState(new Vector3());
    const [size, setSize] = useState(new Vector3());
    const [initialTarget, setInitialTarget] = useState(new Vector3(0, 0, 0));
    const [initialPosition, setInitialPosition] = useState(new Vector3(0, 10, 0));
    const isAnimatingRef = useRef(false); // Animasyon durumu

    // updateCameraBounds fonksiyonu
    const updateCameraBounds = useCallback((newSize: Vector3, newCenter: Vector3) => {
        setSize(newSize);
        setCenter(newCenter);

        if (controlsRef.current) {
            const maxDim = Math.max(newSize.x, newSize.y, newSize.z);

            // ƒ∞lk ge√ßerli pozisyonlarƒ± ayarla
            lastValidTargetRef.current = newCenter.clone();
            lastValidPositionRef.current = camera.position.clone();

            // Ba≈ülangƒ±√ß pozisyonlarƒ±nƒ± ayarla
            setInitialTarget(newCenter.clone());
            setInitialPosition(camera.position.clone());
        }
    }, [camera.position]);

    // Zoom durumunu takip etmek i√ßin ref
    const isZoomingRef = useRef(false);

    useEffect(() => {
        if (controlsRef.current) {
            controlsRef.current.update();

            // Pan i≈ülemini engellemek i√ßin event listener ekle
            const controls = controlsRef.current;

            // Sƒ±nƒ±r kontrol√º i√ßin ek event listener
            const handleChange = () => {
                // Zoom sƒ±rasƒ±nda sƒ±nƒ±r kontrollerini atla
                if (isZoomingRef.current) return;

                const rectWidth = 8800;
                const rectHeight = 4000;
                const xLimit = rectWidth / 5;
                const zLimit = rectHeight / 5;

                const target = controls.target;
                const camera = controls.object;

                // Hedef pozisyonunu kontrol et
                if (Math.abs(target.x) > xLimit || Math.abs(target.z) > zLimit) {
                    console.log('üö´ SINIR A≈ûILDI - EVENT LISTENER!');

                    // Hedef pozisyonunu sƒ±nƒ±rla
                    target.x = Math.max(-xLimit, Math.min(xLimit, target.x));
                    target.z = Math.max(-zLimit, Math.min(zLimit, target.z));

                    // Kamera pozisyonunu da sabit tut
                    const fixedDistance = 1000;
                    camera.position.set(target.x, fixedDistance, target.z);

                    controls.update();
                }

                // Sƒ±nƒ±rlarda kamera pozisyonunu kontrol et
                const isNearBoundary = Math.abs(target.x) >= xLimit * 0.9 || Math.abs(target.z) >= zLimit * 0.9;
                if (isNearBoundary) {
                    const fixedDistance = 1000;
                    camera.position.set(target.x, fixedDistance, target.z);
                    console.log('üîí EVENT LISTENER - Sƒ±nƒ±rlarda kamera pozisyonu sabitlendi');
                }
                // Normal alanlarda zoom'a izin ver
            };

            controls.addEventListener('change', handleChange);

            // Pan i≈ülemini sƒ±nƒ±rlƒ± hale getirmek i√ßin override et
            const originalPan = controls.pan;
            controls.pan = function (deltaX: number, deltaY: number) {
                // DEBUG: Pan i≈ülemini izle
                console.log('üñ±Ô∏è PAN ƒ∞≈ûLEMƒ∞:', {
                    deltaX: deltaX.toFixed(2),
                    deltaY: deltaY.toFixed(2),
                    mevcutHedef: {
                        x: this.target.x.toFixed(2),
                        y: this.target.y.toFixed(2),
                        z: this.target.z.toFixed(2)
                    }
                });

                // Sƒ±nƒ±rlarƒ± kontrol et - Model.tsx'ten alƒ±nan deƒüerler
                const rectWidth = 8800;
                const rectHeight = 4000;
                const xLimit = rectWidth / 5; // Dikd√∂rtgenin yarƒ± geni≈üliƒüi
                const zLimit = rectHeight / 5; // Dikd√∂rtgenin yarƒ± y√ºksekliƒüi

                const newTarget = this.target.clone();
                newTarget.x += deltaX;
                newTarget.z += deltaY;

                console.log('üñ±Ô∏è YENƒ∞ HEDEF:', {
                    x: newTarget.x.toFixed(2),
                    y: newTarget.y.toFixed(2),
                    z: newTarget.z.toFixed(2)
                });

                // Sƒ±nƒ±r kontrol√º - sadece hedef pozisyonunu kontrol et
                if (Math.abs(newTarget.x) > xLimit || Math.abs(newTarget.z) > zLimit) {
                    console.log('üö´ PAN ENGELLENDƒ∞! Sƒ±nƒ±r a≈üƒ±lƒ±yor');
                    console.log('üö´ Sƒ±nƒ±rlar:', { xLimit: xLimit.toFixed(2), zLimit: zLimit.toFixed(2) });
                    return false; // Pan i≈ülemini engelle
                }

                console.log('‚úÖ PAN ƒ∞Zƒ∞N VERƒ∞LDƒ∞');
                // Orijinal pan i≈ülemini √ßaƒüƒ±r
                return originalPan.call(this, deltaX, deltaY);
            };

            // Cleanup
            return () => {
                if (controls) {
                    controls.pan = originalPan;
                    controls.removeEventListener('change', handleChange);
                }
            };
        }
    }, []);

    useFrame(() => {
        if (controlsRef.current && size.length() > 0) {
            controlsRef.current.update();

            // Zoom sƒ±rasƒ±nda sƒ±nƒ±r kontrollerini ge√ßici olarak devre dƒ±≈üƒ± bƒ±rak
            if (isAnimatingRef.current) {
                return; // Animasyon sƒ±rasƒ±nda sƒ±nƒ±r kontrollerini atla
            }

            // Dikt√∂rtgen sƒ±nƒ±rlarƒ± (8800x4000) - Model.tsx'ten alƒ±nan deƒüerler
            const rectWidth = 8800;
            const rectHeight = 4000;

            // Sƒ±nƒ±r limitleri - dikd√∂rtgenin tam k√∂≈üelerine kadar
            const xLimit = rectWidth / 5; // Dikd√∂rtgenin yarƒ± geni≈üliƒüi
            const zLimit = rectHeight / 5; // Dikd√∂rtgenin yarƒ± y√ºksekliƒüi

            const currentTarget = controlsRef.current.target;
            const offset = currentTarget.clone().sub(center);

            // DEBUG: Kamera ve hedef pozisyonlarƒ±nƒ± izle
            const cameraRotation = camera.rotation;
            const targetRotation = controlsRef.current.target;

            // Sadece rotasyon deƒüi≈üimlerini izle
            const currentRotationX = cameraRotation.x;
            const lastRotationX = lastRotationRef.current;

            // Rotasyon deƒüi≈ütiyse log yazdƒ±r
            if (Math.abs(currentRotationX - lastRotationX) > 0.001) {
                console.log('üîÑ ROTASYON DEƒûƒ∞≈ûTƒ∞!', {
                    eski: (lastRotationX * 180 / Math.PI).toFixed(2) + '¬∞',
                    yeni: (currentRotationX * 180 / Math.PI).toFixed(2) + '¬∞',
                    fark: ((currentRotationX - lastRotationX) * 180 / Math.PI).toFixed(2) + '¬∞'
                });
            }

            // Son rotasyon deƒüerini g√ºncelle
            lastRotationRef.current = currentRotationX;

            // Sƒ±nƒ±r kontrol√º - sadece kritik durumlarda
            let needsCorrection = false;
            let correctedTarget = currentTarget.clone();

            // X ekseni sƒ±nƒ±r kontrol√º (geni≈ülik) - daha toleranslƒ±
            if (Math.abs(offset.x) > xLimit * 1.1) { // %10 tolerans
                correctedTarget.x = center.x + (offset.x > 0 ? xLimit : -xLimit);
                needsCorrection = true;
            }

            // Z ekseni sƒ±nƒ±r kontrol√º (y√ºkseklik) - daha toleranslƒ±
            if (Math.abs(offset.z) > zLimit * 1.1) { // %10 tolerans
                correctedTarget.z = center.z + (offset.z > 0 ? zLimit : -zLimit);
                needsCorrection = true;
            }

            // Y ekseni sƒ±nƒ±r kontrol√º (y√ºkseklik - sƒ±nƒ±rlƒ±) - daha toleranslƒ±
            if (Math.abs(offset.y) > 150) { // Y sƒ±nƒ±rƒ± - daha toleranslƒ±
                correctedTarget.y = center.y + (offset.y > 0 ? 100 : -100);
                needsCorrection = true;
            }

            // Sƒ±nƒ±r a≈üƒ±ldƒ±ysa yay animasyonu ile geri at
            if (needsCorrection && !isAnimatingRef.current) {
                isAnimatingRef.current = true;

                const oldTarget = controlsRef.current.target.clone();
                const oldCameraPosition = camera.position.clone();

                // Yay animasyonu i√ßin hedef pozisyonu biraz daha i√ßeri √ßek
                const bounceDistance = 200; // Geri atma mesafesi
                const bounceTarget = correctedTarget.clone();

                if (Math.abs(offset.x) > xLimit * 1.1) {
                    bounceTarget.x = center.x + (offset.x > 0 ? xLimit - bounceDistance : -xLimit + bounceDistance);
                }
                if (Math.abs(offset.z) > zLimit * 1.1) {
                    bounceTarget.z = center.z + (offset.z > 0 ? zLimit - bounceDistance : -zLimit + bounceDistance);
                }

                // GSAP ile yay animasyonu
                gsap.to(controlsRef.current.target, {
                    x: bounceTarget.x,
                    y: bounceTarget.y,
                    z: bounceTarget.z,
                    duration: 1.2,
                    ease: "elastic.out(1, 0.3)", // Yay efekti
                    onUpdate: () => {
                        controlsRef.current.update();
                    },
                    onComplete: () => {
                        isAnimatingRef.current = false;
                        console.log('üéØ YAY ANƒ∞MASYONU TAMAMLANDI!');
                    }
                });

                // Kamera pozisyonu i√ßin de yay animasyonu
                const cameraOffset = camera.position.clone().sub(controlsRef.current.target);
                const maxCameraDistance = 1000;

                if (cameraOffset.length() > maxCameraDistance) {
                    cameraOffset.normalize().multiplyScalar(maxCameraDistance);
                    const newCameraPosition = bounceTarget.clone().add(cameraOffset);

                    gsap.to(camera.position, {
                        x: newCameraPosition.x,
                        y: newCameraPosition.y,
                        z: newCameraPosition.z,
                        duration: 1.2,
                        ease: "elastic.out(1, 0.3)",
                    });
                }

                console.log('üéØ YAY ANƒ∞MASYONU BA≈ûLADI!');
                console.log('üìç Eski hedef:', oldTarget);
                console.log('üìç Yeni hedef:', bounceTarget);
            }

            // Sadece hedef pozisyonunu sakla, kamera pozisyonunu deƒüi≈ütirme
            lastValidTargetRef.current = controlsRef.current.target.clone();

            // Kamera pozisyonunu s√ºrekli kontrol et (otomatik zoom'u engelle)
            const target = controlsRef.current.target;
            const cameraToTarget = camera.position.clone().sub(target);
            const currentDistance = cameraToTarget.length();
            const minDistance = 300;
            const maxDistance = 1050;

            // Sƒ±nƒ±rlarda zoom'u engelle - daha sƒ±kƒ± kontrol
            const isNearBoundary = Math.abs(target.x) >= xLimit * 0.9 || Math.abs(target.z) >= zLimit * 0.9;

            if (isNearBoundary) {
                // Sƒ±nƒ±rlardaysa kamera pozisyonunu tamamen sabit tut
                const fixedDistance = 1000; // Sabit mesafe
                const fixedCameraPosition = new Vector3(
                    target.x,
                    fixedDistance,
                    target.z
                );
                camera.position.copy(fixedCameraPosition);
            } else {
                // Sƒ±nƒ±rlarda deƒüilse normal zoom mesafesini kontrol et (500-900 arasƒ±)
                const minDistance = 500; // Minimum zoom (100 derece FOV)
                const maxDistance = 900; // Maximum zoom (85 derece FOV)

                if (currentDistance < minDistance) {
                    cameraToTarget.normalize().multiplyScalar(minDistance);
                    camera.position.copy(target).add(cameraToTarget);
                } else if (currentDistance > maxDistance) {
                    cameraToTarget.normalize().multiplyScalar(maxDistance);
                    camera.position.copy(target).add(cameraToTarget);
                }
                // Normal aralƒ±kta ise zoom'a izin ver
            }

            // Kamera her karede yukarƒ±dan a≈üaƒüƒ±ya sabit baksƒ±n
            camera.up.set(0, 0, -1);

            // Kamera rotasyonunu sabit tut (harita d√∂nmesin)
            camera.rotation.x = -Math.PI / 2; // -90 derece (√ºstten g√∂r√ºn√ºm)
            camera.rotation.y = 0; // Y ekseni rotasyonu yok
            camera.rotation.z = 0; // Z ekseni rotasyonu yok
        }
    });

    return { controlsRef, updateCameraBounds, isZoomingRef };
}

// MapControls wrapper component
function MapControlsWrapper({ controlsRef, isZoomingRef }: { controlsRef: any; isZoomingRef: any }) {
    // Smooth wheel zoom i√ßin useEffect ile event listener ekle
    useEffect(() => {
        if (controlsRef.current) {
            let zoomTimeout: NodeJS.Timeout;
            let isZooming = false;
            let zoomStartTime = 0;

            const handleWheel = (event: any) => {
                // Event'i engelle (default zoom'u devre dƒ±≈üƒ± bƒ±rak)
                event.preventDefault();

                // Zoom zaten devam ediyorsa yeni zoom'u engelle
                if (isZooming) return;

                // Controls ve camera kontrol√º
                if (!controlsRef.current || !controlsRef.current.object) return;

                // Zoom durumunu hook'a bildir
                isZoomingRef.current = true;

                // Wheel event'i daha hƒ±zlƒ± zoom i√ßin optimize et
                const delta = event.deltaY * 0.002; // Wheel sensitivity'yi 3 kat artƒ±r (0.001 ‚Üí 0.003)
                const camera = controlsRef.current.object;
                const target = controlsRef.current.target;

                // G√ºvenlik kontrol√º
                if (!camera || !camera.position || !target) return;

                // Zoom ba≈ülangƒ±√ß zamanƒ±nƒ± kaydet
                zoomStartTime = Date.now();

                // Daha hƒ±zlƒ± zoom i√ßin g√º√ßlendirilmi≈ü zoom interpolation
                const currentDistance = camera.position.distanceTo(target);
                const zoomFactor = 1 + (delta * 2); // Zoom factor'ƒ±nƒ± 2 kat g√º√ßlendir
                const newDistance = Math.max(500, Math.min(900, currentDistance * zoomFactor));

                // Kamera pozisyonunu smooth ≈üekilde g√ºncelle
                const direction = camera.position.clone().sub(target).normalize();
                const newPosition = target.clone().add(direction.multiplyScalar(newDistance));

                // Zoom durumunu i≈üaretle
                isZooming = true;

                // GSAP ile smooth animation - daha kƒ±sa s√ºre
                gsap.to(camera.position, {
                    x: newPosition.x,
                    y: newPosition.y,
                    z: newPosition.z,
                    duration: 0.15, // Daha hƒ±zlƒ± zoom i√ßin s√ºreyi azalt
                    ease: "power1.out", // Daha yumu≈üak easing
                    onUpdate: () => {
                        if (controlsRef.current) {
                            controlsRef.current.update();
                        }
                    },
                    onComplete: () => {
                        // Zoom bittikten sonra kƒ±sa bir bekleme
                        zoomTimeout = setTimeout(() => {
                            isZooming = false;
                            isZoomingRef.current = false; // Hook'ta zoom durumunu g√ºncelle
                        }, 30); // Daha kƒ±sa bekleme s√ºresi
                    }
                });
            };

            // Wheel event listener ekle
            const canvas = document.querySelector('canvas');
            if (canvas) {
                canvas.addEventListener('wheel', handleWheel, { passive: false });

                // Cleanup
                return () => {
                    canvas.removeEventListener('wheel', handleWheel);
                    if (zoomTimeout) {
                        clearTimeout(zoomTimeout);
                    }
                };
            }
        }
    }, [controlsRef, isZoomingRef]);

    return (
        <MapControls
            ref={controlsRef}
            enablePan={true} // Pan'i geri a√ß
            enableZoom={false} // Zoom'u kapat (kendi wheel handling'imizi kullanƒ±yoruz)
            enableRotate={false} // Rotate'i kapat - harita d√∂nmesin

            minDistance={500} // Minimum zoom (100 derece FOV)
            maxDistance={900} // Maximum zoom (85 derece FOV)
            target={[0, 0, 0]} // Modelin merkezine g√∂re ayarla

            // Smooth zoom i√ßin optimize edilmi≈ü ayarlar
            enableDamping={false} // Damping'i kapat (daha stabil)
            rotateSpeed={0} // Rotate hƒ±zƒ±nƒ± sƒ±fƒ±rla
            panSpeed={0.5}
            zoomSpeed={0.6} // Zoom hƒ±zƒ±nƒ± orta seviyede tut

            maxPolarAngle={Math.PI / 2} // Sadece √ºstten g√∂r√ºn√ºm i√ßin
            minPolarAngle={Math.PI / 2} // Sadece √ºstten g√∂r√ºn√ºm i√ßin (aynƒ± deƒüer)
            screenSpacePanning={true}

            // DEBUG: MapControls ayarlarƒ±nƒ± logla
            onUpdate={() => {
                console.log('üîÑ MAPCONTROLS UPDATE:', {
                    target: controlsRef.current?.target,
                    cameraPosition: controlsRef.current?.object?.position,
                    cameraRotation: controlsRef.current?.object?.rotation
                });
            }}
        />
    );
}

function Harita() {
    return (
        <div style={{
            width: '100vw',
            height: '100vh',
            margin: 0,
            padding: 0,
            backgroundColor: 'black',
            overflow: 'hidden', // Ta≈üan i√ßeriƒüi gizle
            position: 'relative' // Pozisyon referansƒ±
        }}>
            <Canvas
                camera={{
                    position: [0, 1000, 0],
                    fov: 85,
                    near: 0.1,
                    far: 5000
                }}
                gl={{
                    preserveDrawingBuffer: true,
                    antialias: true // Anti-aliasing ekle
                }}
                style={{
                    background: '#000000',
                    overflow: 'hidden', // Ta≈üan i√ßeriƒüi gizle
                    position: 'absolute', // Mutlak pozisyon
                    top: 0,
                    left: 0,
                    width: '100%',
                    height: '100%'
                }}
            >
                <React.Suspense fallback={null}>
                    <SceneContent />
                    {/* Optional: Environment for subtle reflections, not background */}
                    <Environment preset="sunset" background={false} />
                </React.Suspense>
            </Canvas>
        </div>
    );
}

// Canvas i√ßinde kullanƒ±lacak bile≈üen
function SceneContent() {
    const { controlsRef, updateCameraBounds, isZoomingRef } = useMapControls();

    // Smooth camera updates i√ßin useFrame hook'u kaldƒ±rƒ±ldƒ±
    // MapControls'ƒ±n kendi smooth sistemi kullanƒ±lƒ±yor

    return (
        <>
            <Model
                onModelLoaded={updateCameraBounds}
                enableKTX2Texture={true}
                textureRepeatX={1}
                textureRepeatY={1}
                textureOffsetX={0}
                textureOffsetY={0}
            />

            {/* Bulut animasyonlarƒ± */}
            <Clouds />

            {/* Ku≈ü s√ºr√ºleri */}
            <BirdFlocks
                enableBirdFlocks={true}
                birdSpeed={25}
                birdSize={3.0}
                birdCount={4}
            />

            {/* Bayraktar TB2 Drone'larƒ± */}
            <Drones
                enableDrones={true}
                droneSpeed={35}
                droneSize={8.0}
                droneCount={2}
            />

            {/* MapControls: left=pan, right=rotate, scroll=zoom */}
            <MapControlsWrapper controlsRef={controlsRef} isZoomingRef={isZoomingRef} />

            {/* I≈üƒ±klar */}
            <ambientLight intensity={0.6} />
            <directionalLight position={[5, 10, 7.5]} intensity={0.8} castShadow />
            <directionalLight position={[-5, -10, -7.5]} intensity={0.3} />
        </>
    );
}

export default Harita; 